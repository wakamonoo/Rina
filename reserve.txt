<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Rina • Voice-controlled YouTube</title>

    <link
      href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css"
      rel="stylesheet"
    />
    <link
      href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;500;600;700&display=swap"
      rel="stylesheet"
    />

    <style>
      :root {
        --primary: #ff0000;
        --secondary: #ff4d4d;
        --dark: #0f0f0f;
        --darker: #0a0a0a;
        --light: #f1f1f1;
      }
      body {
        background: linear-gradient(135deg, var(--darker), var(--dark));
        min-height: 100vh;
        color: var(--light);
        font-family: "Poppins", sans-serif;
      }
      .glow {
        text-shadow: 0 0 10px rgba(255, 0, 0, 0.7);
      }
      .voice-wave span {
        animation: wave 1.2s infinite ease-in-out;
      }
      @keyframes wave {
        0%, 60%, 100% {
          transform: scaleY(0.4);
        }
        30% {
          transform: scaleY(1);
        }
      }
      .status-pill {
        animation: pulse 2s infinite;
      }
      @keyframes pulse {
        0%, 100% {
          opacity: 0.6;
        }
        50% {
          opacity: 1;
        }
      }
    </style>
  </head>

  <body class="min-h-screen flex flex-col items-center p-4">
    <div class="max-w-md w-full mt-10">
      <header class="text-center mb-8">
        <h1 class="text-4xl font-bold glow">RINA</h1>
        <p class="text-gray-400 mt-2">Voice-controlled YouTube</p>
      </header>

      <div class="bg-gray-900/80 rounded-xl p-6 mb-6 border border-gray-800">
        <div class="flex items-center justify-center gap-3 mb-4">
          <div class="voice-wave h-10">
            <span class="w-1 h-3 bg-red-500 inline-block mx-0.5"></span>
            <span class="w-1 h-3 bg-red-500 inline-block mx-0.5"></span>
            <span class="w-1 h-3 bg-red-500 inline-block mx-0.5"></span>
            <span class="w-1 h-3 bg-red-500 inline-block mx-0.5"></span>
            <span class="w-1 h-3 bg-red-500 inline-block mx-0.5"></span>
          </div>
          <span class="status-pill bg-red-600 text-white text-sm py-1 px-3 rounded-full">Listening</span>
        </div>
        <p id="status" class="text-center text-gray-300">Waiting for a command…</p>
        <p id="transcript" class="text-xs text-center text-gray-500 mt-2 italic"></p>
      </div>

      <div class="bg-gray-900/80 rounded-xl p-4 mb-6 border border-gray-800">
        <h2 class="text-lg font-medium mb-2">Current Playback</h2>
        <div id="nowPlaying" class="text-gray-400 italic">No active playback</div>
        <div class="flex gap-2 mt-3">
          <button id="openBtn" class="bg-red-600 hover:bg-red-700 text-white py-1 px-3 rounded text-sm">Open Player Tab</button>
          <button id="closeBtn" class="bg-gray-700 hover:bg-gray-600 text-white py-1 px-3 rounded text-sm">Close Player</button>
        </div>
      </div>
    </div>

    <script>
      const API_KEY = "AIzaSyDf3KNskO0UHQHggcUDz0ltFbe3F0ppzRE"; // Replace with your real API key
      const PLAYER_ORIGIN = "https://www.youtube.com";

      let ytWin = null;
      let volume = 50;
      let rec = null;

      const statusEl = document.getElementById("status");
      const transcriptEl = document.getElementById("transcript");
      const nowPlayingEl = document.getElementById("nowPlaying");

      document.getElementById("openBtn").onclick = () => ensureYT();
      document.getElementById("closeBtn").onclick = () => {
        if (ytWin && !ytWin.closed) ytWin.close();
        ytWin = null;
        nowPlayingEl.textContent = "No active playback";
      };

      initSpeech();

      function initSpeech() {
        const SR = window.SpeechRecognition || window.webkitSpeechRecognition;
        if (!SR) {
          statusEl.textContent = "Speech-API not supported";
          return;
        }

        rec = new SR();
        rec.lang = "en-US";
        rec.continuous = true;
        rec.interimResults = true;

        rec.onresult = (e) => {
          const last = e.results[e.results.length - 1];
          if (!last.isFinal) return;
          const cmd = last[0].transcript.trim().toLowerCase();
          transcriptEl.textContent = cmd;
          handleCommand(cmd);
          setTimeout(() => (transcriptEl.textContent = ""), 800);
        };

        rec.onerror = (e) => (statusEl.textContent = "Mic error: " + e.error);
        rec.onend = () => rec.start();
        rec.start();
      }

      function handleCommand(cmd) {
        statusEl.textContent = `Heard: “${cmd}”`;
        cmd = cmd.replace(/^rina\b/, "").trim();

        if (cmd === "pause") send("pauseVideo");
        else if (cmd === "play") send("playVideo");
        else if (cmd === "next") send("nextVideo");
        else if (cmd === "previous") send("previousVideo");
        else if (cmd === "mute") send("mute");
        else if (cmd === "unmute") send("unMute");
        else if (cmd === "volume up") {
          volume = Math.min(volume + 10, 100);
          send("setVolume", [volume]);
        } else if (cmd === "volume down") {
          volume = Math.max(volume - 10, 0);
          send("setVolume", [volume]);
        } else if (cmd.match(/\b(\d+(?:\.\d+)?)x\b/) || cmd.includes("speed")) {
          const rate = parseFloat((cmd.match(/[\d.]+/) || ["1"])[0]);
          send("setPlaybackRate", [rate]);
        } else if (cmd.startsWith("play ")) {
          const query = cmd.slice(5).trim();
          if (query) searchPlay(query);
        } else {
          // Default: treat any other input as a search query
          searchPlay(cmd);
        }
      }

      function ensureYT(url) {
        if (ytWin && !ytWin.closed) {
          if (url) ytWin.location.replace(url);
          ytWin.focus();
          return ytWin;
        }
        ytWin = window.open(url || "about:blank", "rina_youtube_tab");
        setTimeout(() => postRaw('{"event":"listening","id":""}'), 800);
        return ytWin;
      }

      function send(func, args = []) {
        postRaw(JSON.stringify({ event: "command", func, args, id: "" }));
      }

      function postRaw(msg) {
        if (ytWin && !ytWin.closed) ytWin.postMessage(msg, PLAYER_ORIGIN);
      }

      async function searchPlay(query) {
        statusEl.textContent = "Searching...";
        try {
          const res = await fetch(
            `https://www.googleapis.com/youtube/v3/search?part=snippet&type=video&maxResults=5&q=${encodeURIComponent(
              query
            )}&key=${API_KEY}`
          );
          const data = await res.json();
          const items = data.items || [];

          for (let item of items) {
            const vid = item.id.videoId;
            const check = await fetch(
              `https://www.googleapis.com/youtube/v3/videos?part=status&id=${vid}&key=${API_KEY}`
            );
            const vidData = await check.json();
            const isEmbeddable = vidData.items?.[0]?.status?.embeddable;
            if (!isEmbeddable) continue;

            const title = item.snippet.title;
            nowPlayingEl.textContent = `Playing: ${title}`;
            const url = `https://www.youtube.com/embed/${vid}?autoplay=1&mute=1&enablejsapi=1&origin=${location.origin}`;
            ensureYT(url);
            setTimeout(() => send("unMute"), 1800);
            return;
          }

          statusEl.textContent = "No embeddable results found.";
          nowPlayingEl.textContent = "No playable video found.";
        } catch (err) {
          console.error("Search error:", err);
          statusEl.textContent = "Error during search.";
          nowPlayingEl.textContent = "Search failed.";
        }
      }
    </script>
  </body>
</html>
